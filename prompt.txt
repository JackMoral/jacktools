на cython реализован цикулирующий буффер

```cython
cdef class BufferInt2d:

    def __cinit__(self, int max_size, tuple[UpdaterInt2d, ...] updaters, object values = None, int row_length = 1):
        cdef int i, j
        cdef UpdaterInt2d updater

        self.max_size = max_size
        self.max_idx = max_size - 1
        self.curr_idx = 0
        self.count = 0
        self.is_full = False
        self.row_length = row_length
        self.row_size = row_length * sizeof(int*)
        self.updaters = updaters
        self.buffer = <int**> malloc(max_size * sizeof(int*))
        if self.buffer == NULL:
            raise MemoryError("Недостаточно памяти!")
        
        for i from 0 <= i < max_size:
            self.buffer[i] = <int *> malloc(self.row_size)
            if self.buffer[i] == NULL:
                for j from 0 <= j < i:
                    if self.buffer[j] != NULL:
                        free(self.buffer[j])
                free(self.buffer)
                self.buffer = NULL
                raise MemoryError("Недостаточно памяти!")
        
        for updater in updaters:
            updater.buffer = self

        if values:
            for value in values:
                self.add(value)

    def __dealloc__(self):
        cdef int i
        if self.buffer != NULL:
            for i from 0 <= i < self.max_size:
                if self.buffer[i] != NULL:
                    free(self.buffer[i])
            free(self.buffer)
    
    cpdef void add(self, object value):
        cdef int i
        cdef int *old_vals
        cdef int *new_vals = self.buffer[self.curr_idx]
        cdef UpdaterInt2d updater
        try:
            if self.is_full:
                old_vals = <int*> malloc(self.row_size)
                memcpy(old_vals, new_vals, self.row_size)
                if old_vals == NULL:
                    raise MemoryError('Недостаточно памяти!')
                for i from 0 <= i < self.row_length:
                    new_vals[i] = value[i]
                
                for updater in self.updaters:
                    updater.update(new_vals, old_vals, self.is_full)
                
            else:
                self.count += 1
                for i from 0 <= i < self.row_length:
                    new_vals[i] = value[i]
                
                for updater in self.updaters:
                    updater.update(new_vals, old_vals, self.is_full)
                
                if self.count >= self.max_size:
                    self.is_full = True
            
        finally:
            if old_vals != NULL:
                free(old_vals)

        if self.curr_idx != self.max_idx:
            self.curr_idx += 1
        else:
            self.curr_idx = 0
```
При инициализации он принимает апдейтеров которых после вызывает передовая данные, базовоя сигнатура буфера и апдейтера выглядят так

```cython
cdef class BufferInt2d:
    cdef readonly:
        int max_size
        int count
        bint is_full
    cdef:
        int curr_idx
        int max_idx
        int **buffer
        int row_length
        size_t row_size
        tuple[UpdaterInt2d, ...] updaters
    cpdef void add(self, object value)

cdef class UpdaterInt2d:
    cdef BufferInt2d buffer
    cdef void update(self, int *new, int *old, bint is_full)
```

Вот пример простой реализации апдейтера

```cython
from libc.stdlib cimport malloc, free
from jacktools.buffer cimport UpdaterInt2d


cdef class OutcomeInt2d(UpdaterInt2d):

    cdef: 
        int *outcome
        double *double_chance

    def __cinit__(self):
        self.outcome = <int*> malloc(3 * sizeof(int))
        if self.outcome == NULL:
            raise MemoryError('Недостаточно памяти')
        
        self.double_chance = <double*> malloc(3 * sizeof(double))
        if self.double_chance == NULL:
            free(self.outcome)
            self.outcome = NULL
            raise MemoryError('Недостаточно памяти')
        
        self.outcome[0] = 0
        self.outcome[1] = 0
        self.outcome[2] = 0
        self.double_chance[0] = 0
        self.double_chance[1] = 0
        self.double_chance[2] = 0
                
    def __dealloc__(self):
        if self.outcome != NULL:
            free(self.outcome)
            self.outcome = NULL
        if self.double_chance != NULL:
            free(self.double_chance)
            self.double_chance = NULL

    cdef void update(self, int *new, int *old, bint is_full):
        cdef: 
            int a = new[0] 
            int b = new[1]
            int a2, b2

        if is_full:
            a2 = old[0]
            b2 = old[1]
            if a2 > b2:
                self.outcome[0] -= 1
                self.double_chance[0] -= 0.5
                self.double_chance[1] -= 0.5
            elif a2 < b2:
                self.outcome[2] -= 1
                self.double_chance[2] -= 0.5
                self.double_chance[1] -= 0.5
            else:
                self.outcome[1] += 1
                self.double_chance[0] += 0.5
                self.double_chance[2] += 0.5

        if a > b:
            self.outcome[0] += 1
            self.double_chance[0] += 0.5
            self.double_chance[1] += 0.5
        elif a < b:
            self.outcome[2] += 1
            self.double_chance[2] += 0.5
            self.double_chance[1] += 0.5
        else:
            self.outcome[1] += 1
            self.double_chance[0] += 0.5
            self.double_chance[2] += 0.5
    
    cpdef tuple[list[int], list[float]] get(self):
        return (
            [self.outcome[0], self.outcome[1], self.outcome[2]], 
            [self.double_chance[0], self.double_chance[1], self.double_chance[2]]
        )
```

Цель: Разработать и реализовать апдейтер StrengthInt2d наследующийся от UpdaterInt2d с алгоритмом для подсчета силы команд в реальном времени на основе результатов их матчей. 
Алгоритм должен обрабатывать матчи последовательно (в потоке) и обновлять рейтинги с константной сложностью O(1) на один матч.

Исходные условия:
    Изначально сила каждой команды равна 0.
    Данные поступают в виде потока событий: (*new=[Счет_A, Счет_B], *old=[Счет_A, Счет_B], is_full=True) в метод update.
    Если is_full = True то нужно пересчитать значения old и сделать вычет из текущего состояния

Основные правила обновления силы:
    
    Определение исхода:
        Победившая команда получает прирост силы, проигравшая — штраф.
        В случае ничьий, силы команд должны двигаться друг к другу (выравниваться).
    
    Базовое изменение силы:
        Каждое очко в счёте должно идти в массы силы.
        Сила может иметь отрицательное значение.

    Коэффициент фаворита/аутсайдера (K-фактор):
        Алгоритм должен учитывать разницу в силе команд до матча.
        Если фаворит побеждает: Он получает меньший прирост, чем базовый.
        Если аутсайдер побеждает: Он получает больший прирост, чем базовый.
        При ничьей: Сила фаворита и сила аутсайдера двужутся к среднему сумм их сил по заданому через cinit коэфициенту.

Тестовое окно данных: [[1,0],[2,1],[3,0],[1,4],[2,2]]
Примерный вывод strengthA, strengthB: [[0.5, -0.5], [1.75, 0.25], ...]
Реальный вывод будет отличатся в зависимости от настроек коэфициентов при инициализации.
Основная настройка это коэфицент выравнивания при ничье, от него и отталкиваемся для начисления бонусов или штрафов силы.